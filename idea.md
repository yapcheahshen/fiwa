# 一些想法

## 名詞
compute, operation             都可以稱為「算」。
cpu instruction                駖 指揮芯片工作的指令，大約百來個，每駖由一到三個漢字組成。
operand, parameter, variable， 作為算的材料皆可為「籌」。
local variable                 私籌、可以無名。只有䮶自己看得到的籌。
local variable (from caller)   棧籌、可以無名。從其他䮶放在棧上的，供本䮶使用，用法同私籌。
global variable                公籌，厩內䮶都可見的，必須帶名字。
constant                       定籌，必須帶名字。籌是運算的素材，類似名詞（即日語中的體言）。
function                       䮶。多個駖排列成為「䮶」，從「棧」取「籌」進行計算，並將結果留在「棧」上。
                               䮶定義了功能作用，可以理解為日語中的「用言」。
                               䮶由四部份組成：䮶名、䮶號、䮶𫘏及䮶䮡。即它的名稱，代號，型別和實作。
                               對人而言，䮶必須有名，否則無以喚之，對芯片而言，只認䮶號。
module                         厩，相關的䮶、運算必要的草料包裝了一個整理。
stack                          棧。駖默認從棧取籌及放籌，一個複雜的計算涉及多個䮶，彼此靠棧來接力交棒。
memory                         倉，即內存。
code memory area               駖倉。
literal                        在駖倉而非駖的數值，稱為「笅」。
                               笅是計算機操作的核心單元，決定了計算位數和內存通道的寬度。真實計算機的笅型通常是固定的。
data type i32, i64, f32, f64   笅有四種，整數的32位「圭」，64位「卦」，32位浮數 「䳏」，64位「𦐰」。
                               這四個字是笅的名字，也是唯一四個可以從駖倉將數值入棧的駖名。
data memory area               料倉，可放任何資料，駖本身也是數字而已，但放在料倉芯片不會視之為駖。
load from memory               入，籴, 𩿩 糴  四種笅「從倉提笅入棧」的駖。
store to  memory               出，粜，𥽀，糶  四種笅「將笅出棧存倉」的駖。
two operands operation         「雙籌算」 ，取棧上兩籌，計算，放回棧。
                               例： 「圭3 圭5 相加」 表示從駖倉取「圭3」和「圭5」做加法，將結果 8 放回棧(也是一個圭）。
                               不同類型的笅不能直接操作，即「圭」「卦」不能相加。
                               為便利理解，初期假設所有的笅都是「圭」即可，在本設計中，筆劃較少都是較基本的笅型。
                               我們可以設計一個驊： (圭₁相加) 意思是往前取一個「符」。在前面加「圭」
                               記作 「3加5」 ，注意「加」是一個䮶，而「相加」是才是駖。
import 騋 export 𩢎
pointer          䇛
memory address 倉䄳 
return address   砋 
url              䊼
stack overflow   爆棧
stack underflow  竭棧

## 編程
因為駖過於低階，䮶是最關鍵的人機橋樑，
所謂編程，就是從駖開始，逐層設置越來越接近人類目標的䮶。
人類撰寫的源代碼，稱為騵(.fiwa) ，編程就是在寫騵文。

必須將騵翻譯為二位制格式的駁文(.wasm)，機器才能夠執行。
具體分為三個流程：  剖符 騽 駁厩
- 剖符
  騵是utf-8 的純文本格式，騵文件分有三種文素：
     給人看的「純註解」、夾在註解中，指引剖符器的「符駖」，和最終產生駁文的主體：騵文。
     要寫出質量上乘的騵文，必須搭配驗文，騵文用最精簡的語句指揮芯片幹活，
     驗文則不嫌其煩地，將每一條可能路徑都一一驗證，以確保騵文符合預期。
     先寫驗，再寫剛好能夠通過驗的騵，一通過就立刻回頭寫驗，這是一個好習慣，稱為「驗驅開發」。

騵文首先會被剖成一個個符，剖符器踫到特殊的符，會進入註解模式，
特殊的符有兩類，一是反斜線，從反斜線到行末的文字，一律視為純註解，不予理會，也不會編成駁文。
而小括號所包夾的文字，在這兩種情況下，會被處理，
一）在剖符階段，可以定義「驊」，「驊」的作用是讓騵文更貼近人類的表述方式，是人機語言轉換的模版。
（助記法：驊指紅色的馬。此處驊借英文是Macro義（宏或巨集），Macro最初的作用是，以較簡潔的表達式，讓程式自動展開為較為繁複的語法，如 C 語言中的 \#define 和 微軟的 Macro Assembler，因為高階語言的編譯軟件不容易編寫，所以很多語言最初都是以Macro的方式早創，比如C++ ）
二）在匯編階段，緊接在䮶名之後。設置「𫘏」 （𫘏文 定義了 䮶 的輸入笅型或籌名和留棧籌數，以及在計算過程中用到的私籌）
* 剖符器只是將騵文分解，套用驊文調整語序，產生一個符號串列，但不解析符號的語義。

- 馴騽

* 識別符號的種類（䮶名、駖名、籌名或是數值），就和自然語言一樣，不同位置的符，會有不同的語義。
* 逐步轉譯為駁文，踫到不能識別的符，會先假設是未知的「䮶」先標註下來，此時尚未能確定這個䮶是否真的存在。
* 踫到「䮶起符」之後的第一個符為䮶名，接著是小括內的𫘏文，直至「䮶終符」。
* 從「䮶起符」都「䮶終符」，實作了一個䮶。䮶由䮶名、𫘏、䮡和自動賦於的䮶號所構成。
* 䮶實只由駖構成，可再細分「笅」「籌」「駖」「䮶」四類。「笅」為從駖倉載入的數值，只有四種。
「籌」指「取公/私籌」「提私籌」「存公/私籌」故共五種，無名籌以不同裝飾的數字表示。
* 其餘的「駖」負責實際計算及控制流向。數量最多，但常用的只有幾個。
* 䮶實中最重要的駖是「使喚」，意義是躍入另一䮡內，完成動作後再躍回，這是高階語言的由簡到繁的組織方式。
* 躍入必定是從䮶頭開始，可以中途躍回。回返點是不變的，比方使喚某人辦事，他可能辦完，也可能沒辦成，
但他一定回到當初收到召令的地方回報成果，因為你只能在那裡等著。
* 騵文中沒有直接出現「使喚」這個駖，只要出現「䮶名」之處皆是使喚，但在駁文中，是以䮶號方式儲存。
* 騵文改動後，即使䮶名不變，但䮶號可能會變。䮶名是給人識別用的，駖只能靠䮶號才得以躍入其他䮡。
* 整篇完成後，再到之前所有的標註點，填入相應的䮶號。
* 任何一個有名無䮡的䮶都會導至匯編失敗，並會回報這個害群之䮶。

- 駁厩
* 將許多䮶以及其他配套的設置，封裝成一個整體模塊，稱為「厩」。
* 此模塊可供有Wasm虛擬機環境的使用，如瀏覽器或裝有Wasm解釋器/編譯器的系統。
* 厩可以將䮶出口，出口的名字可以不同（要特別區分的場合稱為𩢎）。
* 通常厩也進口了一些䮶，稱為「騋」，如果移到一個無法提供的環境，則這個厩無法順利運行（但可以觀察它）。
* 觀察的手段稱為反匯編。官方標準的格式是囉嗦的WAT。

### 漢語的剖符。
- 計算機一板一眼，沒有自然語言的靈活性和容錯性。
- 所有的高階語言，表面上是英文，但單詞並不曲折，而是利用符號的相對位置來表義。
- 為了讓騵文貼近漢語的表述，就不能以空格來切分符號。
- 剖符規則非常簡單，連續的漢字先視為一單元，任何字母數字標點符號，空格等都能分隔它。
- 剖符器一開始不需要預先建立詞彙表，而是在過程中逐步認識新詞。
- 設有一條騵文「參加人數加10」，意義自明，首先會被剖成「參加人數加」「10」兩個符號。
- 計算機可以識別「10」，但無法識別「參加人數加」，報錯。

### 驊文的引入
- 補一條驊 (#加 圭₁相加)，這樣剖符器就能夠識別「加」這個符號，它會抽取緊接在後的一個符號，
  並前綴以「圭」，後綴以「相加」。
- 再試「參加人數加」，字典中沒有以「參」開頭的字，只好往下移一字，發現「加」，它起了分隔的作用，
- 此時被剖成：參,加,人數,加,10。
- 因為驊文中指定，「₁」指下一籌 (₂是再下一籌），「ₘₙ」則指非籌符（如䮶或支駖」。
- 對第一個「加」而言，「₁」對應了「人數」，即非籌（也不是駖，只能是䮶）故跳過。
- 對第二個「加」，「₁」是10，符合條件，「加10」按驊文規定，換成「圭10相加」。
- 驊文的轉換的一次性的，「圭10相加」即使內含有「加」但也不再觸發「加」這個驊。
- 計算機看到的結果是： 「參加人數,圭10相加」 ，從圭開始，電腦可以讀懂了。
- 最後再定義一個名為「參加人數」的公籌，這段騵文就可以通過匯編了。
- 對人而言依舊說「參加人數加10」，但經過驊文和公籌，人話成了芯片的命令，此謂人機交心。

## 設計目標
- 利用漢字的特性簡潔地轉譯虛擬指令，比英文母字有更強的表現力。
  例： i64_shr_s    :"廂右移",   「相」表示這是一個雙籌算
  f32_convert_i64_s:"䳏變啩"

- Wasm Text 用 Lisp style 表達，一方面要準確表達每個後置式的指令，
另一方面又要遷就高階語言熟悉的套疊，語法顯得很瑣碎，
改用中文指令，一整頁程式可以變成一兩行。

這是Fibonacci算法的16進制機械碼：2000410249044020000F0B200041026B1000200041016B10006A0F0B
訓練有素的程序猿可以讀出每一個爼的數值，但顯然，這不是一般人類可以快速理解的。

將機械碼逐一以中文指令轉寫         Ⓕ=「⑴圭2相小？圭⑴返。⑴圭2相減Ⓕ⑴圭1相減Ⓐ相加返。」
限定為32bits並用驊文逆轉為內置語法：Ⓕ=「⑴小於2？⑴返。⑴減2Ⓕ⑴減1Ⓕ相加返。」  驊文(#減 圭₁相減)
口語為：「第一個區域變數如果小於2，則返回它。否則將它減2自喚，再將它減1再自喚。（兩次計算的結果）相加返回。」

以下為等效的 Wasm Text 代碼(由 DevTools 生成)
(module
  (func $fib (;0;) (export "fib") (param $var0 i32) (result i32)
    local.get $var0
    i32.const 2
    i32.lt_u
    if
      local.get $var0
      return
    end
    local.get $var0
    i32.const 2
    i32.sub
    call $fib
    local.get $var0
    i32.const 1
    i32.sub
    call $fib
    i32.add
    return
  )
)

- 自舉 (self compile)
- 